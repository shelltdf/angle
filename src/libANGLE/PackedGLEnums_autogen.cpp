// GENERATED FILE - DO NOT EDIT.
// Generated by gen_packed_gl_enums.py using data from packed_gl_enums.json.
//
// Copyright 2018 The ANGLE Project Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file.
//
// PackedGLEnums_autogen.cpp:
//   Implements ANGLE-specific enums classes for GLEnum and functions operating
//   on them.

#include "libANGLE/PackedGLEnums_autogen.h"
#include "common/debug.h"

namespace gl
{

template <>
BufferBinding FromGLenum<BufferBinding>(GLenum from)
{
    switch (from)
    {
        case GL_ARRAY_BUFFER:
            return BufferBinding::Array;
        case GL_ATOMIC_COUNTER_BUFFER:
            return BufferBinding::AtomicCounter;
        case GL_COPY_READ_BUFFER:
            return BufferBinding::CopyRead;
        case GL_COPY_WRITE_BUFFER:
            return BufferBinding::CopyWrite;
        case GL_DISPATCH_INDIRECT_BUFFER:
            return BufferBinding::DispatchIndirect;
        case GL_DRAW_INDIRECT_BUFFER:
            return BufferBinding::DrawIndirect;
        case GL_ELEMENT_ARRAY_BUFFER:
            return BufferBinding::ElementArray;
        case GL_PIXEL_PACK_BUFFER:
            return BufferBinding::PixelPack;
        case GL_PIXEL_UNPACK_BUFFER:
            return BufferBinding::PixelUnpack;
        case GL_SHADER_STORAGE_BUFFER:
            return BufferBinding::ShaderStorage;
        case GL_TRANSFORM_FEEDBACK_BUFFER:
            return BufferBinding::TransformFeedback;
        case GL_UNIFORM_BUFFER:
            return BufferBinding::Uniform;
        default:
            return BufferBinding::InvalidEnum;
    }
}

GLenum ToGLenum(BufferBinding from)
{
    switch (from)
    {
        case BufferBinding::Array:
            return GL_ARRAY_BUFFER;
        case BufferBinding::AtomicCounter:
            return GL_ATOMIC_COUNTER_BUFFER;
        case BufferBinding::CopyRead:
            return GL_COPY_READ_BUFFER;
        case BufferBinding::CopyWrite:
            return GL_COPY_WRITE_BUFFER;
        case BufferBinding::DispatchIndirect:
            return GL_DISPATCH_INDIRECT_BUFFER;
        case BufferBinding::DrawIndirect:
            return GL_DRAW_INDIRECT_BUFFER;
        case BufferBinding::ElementArray:
            return GL_ELEMENT_ARRAY_BUFFER;
        case BufferBinding::PixelPack:
            return GL_PIXEL_PACK_BUFFER;
        case BufferBinding::PixelUnpack:
            return GL_PIXEL_UNPACK_BUFFER;
        case BufferBinding::ShaderStorage:
            return GL_SHADER_STORAGE_BUFFER;
        case BufferBinding::TransformFeedback:
            return GL_TRANSFORM_FEEDBACK_BUFFER;
        case BufferBinding::Uniform:
            return GL_UNIFORM_BUFFER;
        default:
            UNREACHABLE();
            return GL_NONE;
    }
}

template <>
BufferUsage FromGLenum<BufferUsage>(GLenum from)
{
    switch (from)
    {
        case GL_DYNAMIC_COPY:
            return BufferUsage::DynamicCopy;
        case GL_DYNAMIC_DRAW:
            return BufferUsage::DynamicDraw;
        case GL_DYNAMIC_READ:
            return BufferUsage::DynamicRead;
        case GL_STATIC_COPY:
            return BufferUsage::StaticCopy;
        case GL_STATIC_DRAW:
            return BufferUsage::StaticDraw;
        case GL_STATIC_READ:
            return BufferUsage::StaticRead;
        case GL_STREAM_COPY:
            return BufferUsage::StreamCopy;
        case GL_STREAM_DRAW:
            return BufferUsage::StreamDraw;
        case GL_STREAM_READ:
            return BufferUsage::StreamRead;
        default:
            return BufferUsage::InvalidEnum;
    }
}

GLenum ToGLenum(BufferUsage from)
{
    switch (from)
    {
        case BufferUsage::DynamicCopy:
            return GL_DYNAMIC_COPY;
        case BufferUsage::DynamicDraw:
            return GL_DYNAMIC_DRAW;
        case BufferUsage::DynamicRead:
            return GL_DYNAMIC_READ;
        case BufferUsage::StaticCopy:
            return GL_STATIC_COPY;
        case BufferUsage::StaticDraw:
            return GL_STATIC_DRAW;
        case BufferUsage::StaticRead:
            return GL_STATIC_READ;
        case BufferUsage::StreamCopy:
            return GL_STREAM_COPY;
        case BufferUsage::StreamDraw:
            return GL_STREAM_DRAW;
        case BufferUsage::StreamRead:
            return GL_STREAM_READ;
        default:
            UNREACHABLE();
            return GL_NONE;
    }
}

template <>
CullFaceMode FromGLenum<CullFaceMode>(GLenum from)
{
    switch (from)
    {
        case GL_BACK:
            return CullFaceMode::Back;
        case GL_FRONT:
            return CullFaceMode::Front;
        case GL_FRONT_AND_BACK:
            return CullFaceMode::FrontAndBack;
        default:
            return CullFaceMode::InvalidEnum;
    }
}

GLenum ToGLenum(CullFaceMode from)
{
    switch (from)
    {
        case CullFaceMode::Back:
            return GL_BACK;
        case CullFaceMode::Front:
            return GL_FRONT;
        case CullFaceMode::FrontAndBack:
            return GL_FRONT_AND_BACK;
        default:
            UNREACHABLE();
            return GL_NONE;
    }
}

template <>
TextureTarget FromGLenum<TextureTarget>(GLenum from)
{
    switch (from)
    {
        case GL_TEXTURE_2D:
            return TextureTarget::_2D;
        case GL_TEXTURE_2D_ARRAY:
            return TextureTarget::_2DArray;
        case GL_TEXTURE_2D_MULTISAMPLE:
            return TextureTarget::_2DMultisample;
        case GL_TEXTURE_3D:
            return TextureTarget::_3D;
        case GL_TEXTURE_EXTERNAL_OES:
            return TextureTarget::External;
        case GL_TEXTURE_RECTANGLE_ANGLE:
            return TextureTarget::Rectangle;
        case GL_TEXTURE_CUBE_MAP_POSITIVE_X:
            return TextureTarget::CubeMapPositiveX;
        case GL_TEXTURE_CUBE_MAP_NEGATIVE_X:
            return TextureTarget::CubeMapNegativeX;
        case GL_TEXTURE_CUBE_MAP_POSITIVE_Y:
            return TextureTarget::CubeMapPositiveY;
        case GL_TEXTURE_CUBE_MAP_NEGATIVE_Y:
            return TextureTarget::CubeMapNegativeY;
        case GL_TEXTURE_CUBE_MAP_POSITIVE_Z:
            return TextureTarget::CubeMapPositiveZ;
        case GL_TEXTURE_CUBE_MAP_NEGATIVE_Z:
            return TextureTarget::CubeMapNegativeZ;
        default:
            return TextureTarget::InvalidEnum;
    }
}

GLenum ToGLenum(TextureTarget from)
{
    switch (from)
    {
        case TextureTarget::_2D:
            return GL_TEXTURE_2D;
        case TextureTarget::_2DArray:
            return GL_TEXTURE_2D_ARRAY;
        case TextureTarget::_2DMultisample:
            return GL_TEXTURE_2D_MULTISAMPLE;
        case TextureTarget::_3D:
            return GL_TEXTURE_3D;
        case TextureTarget::External:
            return GL_TEXTURE_EXTERNAL_OES;
        case TextureTarget::Rectangle:
            return GL_TEXTURE_RECTANGLE_ANGLE;
        case TextureTarget::CubeMapPositiveX:
            return GL_TEXTURE_CUBE_MAP_POSITIVE_X;
        case TextureTarget::CubeMapNegativeX:
            return GL_TEXTURE_CUBE_MAP_NEGATIVE_X;
        case TextureTarget::CubeMapPositiveY:
            return GL_TEXTURE_CUBE_MAP_POSITIVE_Y;
        case TextureTarget::CubeMapNegativeY:
            return GL_TEXTURE_CUBE_MAP_NEGATIVE_Y;
        case TextureTarget::CubeMapPositiveZ:
            return GL_TEXTURE_CUBE_MAP_POSITIVE_Z;
        case TextureTarget::CubeMapNegativeZ:
            return GL_TEXTURE_CUBE_MAP_NEGATIVE_Z;
        default:
            UNREACHABLE();
            return GL_NONE;
    }
}

template <>
TextureType FromGLenum<TextureType>(GLenum from)
{
    switch (from)
    {
        case GL_TEXTURE_2D:
            return TextureType::_2D;
        case GL_TEXTURE_2D_ARRAY:
            return TextureType::_2DArray;
        case GL_TEXTURE_2D_MULTISAMPLE:
            return TextureType::_2DMultisample;
        case GL_TEXTURE_3D:
            return TextureType::_3D;
        case GL_TEXTURE_EXTERNAL_OES:
            return TextureType::External;
        case GL_TEXTURE_RECTANGLE_ANGLE:
            return TextureType::Rectangle;
        case GL_TEXTURE_CUBE_MAP:
            return TextureType::CubeMap;
        default:
            return TextureType::InvalidEnum;
    }
}

GLenum ToGLenum(TextureType from)
{
    switch (from)
    {
        case TextureType::_2D:
            return GL_TEXTURE_2D;
        case TextureType::_2DArray:
            return GL_TEXTURE_2D_ARRAY;
        case TextureType::_2DMultisample:
            return GL_TEXTURE_2D_MULTISAMPLE;
        case TextureType::_3D:
            return GL_TEXTURE_3D;
        case TextureType::External:
            return GL_TEXTURE_EXTERNAL_OES;
        case TextureType::Rectangle:
            return GL_TEXTURE_RECTANGLE_ANGLE;
        case TextureType::CubeMap:
            return GL_TEXTURE_CUBE_MAP;
        default:
            UNREACHABLE();
            return GL_NONE;
    }
}

}  // namespace gl
